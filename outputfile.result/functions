
/**
 * Taille du buffer utilisé pour la lecture et l'écriture des fichiers.
 */
/**
 * \brief Ouvre un fichier en mode spécifié.
 *
 * La fonction open_file() tente d'ouvrir un fichier avec le nom et le mode spécifiés.
 * Si l'ouverture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param filename Le nom du fichier à ouvrir.
 * \param mode Le mode d'ouverture du fichier (ex: "r" pour lecture, "w" pour écriture, "a" pour ajout).
 * \return Un pointeur vers le fichier ouvert, ou NULL en cas d'échec.
 */
FILE* open_file(const char *filename, const char *mode)
{
    FILE *file = fopen(filename, mode);
    if (file == NULL)
    {
        perror("fopen");
        exit(EXIT_FAILURE);
    }
    return file;
}
/**
 * \brief Lit le contenu d'un fichier dans un buffer.
 *
 * La fonction read_file() alloue un buffer de taille BUFSIZE et lit les données du fichier dans ce buffer.
 * Si l'allocation de mémoire ou la lecture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param file Le pointeur vers le fichier à lire.
 * \return Un pointeur vers le buffer contenant les données lues, ou NULL en cas d'échec.
 */
char* read_file(FILE *file)
{
    char *buffer = (char *)malloc(BUFSIZE * sizeof(char));
    if (buffer == NULL)
    {
        perror("malloc buffer");
        exit(EXIT_FAILURE);
    }
    size_t sz = fread(buffer, sizeof(char), BUFSIZE, file);
    if (sz == 0 && ferror(file))
    {
        perror("fread");
        free(buffer);
        exit(EXIT_FAILURE);
    }
    return buffer;
}
/**
 * \brief Écrit le contenu d'un buffer dans un fichier.
 *
 * La fonction write_file() écrit les données du buffer dans le fichier spécifié.
 * Si l'écriture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param file Le pointeur vers le fichier où écrire.
 * \param buffer Le buffer contenant les données à écrire.
 */
void write_file(FILE *file, const char *buffer)
{
    size_t sz = fwrite(buffer, sizeof(char), BUFSIZE, file);
    if (sz != BUFSIZE)
    {
        perror("fwrite");
        exit(EXIT_FAILURE);
    }
}
/**
 * \brief Ferme un fichier.
 *
 * La fonction close_file() ferme le fichier spécifié.
 * Si la fermeture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param file Le pointeur vers le fichier à fermer.
 */
void close_file(FILE *file)
{
    if (fclose(file) == EOF)
    {
        perror("fclose");
        exit(EXIT_FAILURE);
    }
}
/**
 * \brief Crée un processus enfant en utilisant la fonction fork().
 *
 * La fonction create_child_process() utilise la fonction fork() pour créer un nouveau processus enfant.
 * Si la création du processus échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \return L'identifiant du processus enfant (pid_t) si la création réussit, ou -1 en cas d'échec.
 */
pid_t create_child_process()
{
    pid_t pid = fork();
    if (pid == -1)
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    return pid;
}
/**
 * \brief Attend la fin d'un processus enfant.
 *
 * La fonction wait_for_child() utilise la fonction waitpid() pour attendre la fin d'un processus enfant spécifié.
 * Elle affiche un message indiquant si le processus enfant s'est terminé normalement ou a été terminé par un signal.
 * Si l'attente échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param pid L'identifiant du processus enfant à attendre.
 */
void wait_for_child(pid_t pid)
{
    int status;
    if (waitpid(pid, &status, 0) == -1)
    {
        perror("waitpid");
        exit(EXIT_FAILURE);
    }
    if (WIFEXITED(status))
    {
        printf("Child process %d exited with status %d\n", pid, WEXITSTATUS(status));
    }
    else if (WIFSIGNALED(status))
    {
        printf("Child process %d terminated by signal %d\n", pid, WTERMSIG(status));
    }
}
/**
 * \brief Exécute une fonction dans le contexte du processus enfant.
 *
 * La fonction execute_in_child() appelle la fonction spécifiée avec l'argument donné dans le contexte du processus enfant.
 *
 * \param func Un pointeur vers la fonction à exécuter.
 * \param arg L'argument à passer à la fonction.
 */
void execute_in_child(void (*func)(void *), void *arg)
{
    func(arg);
}
/**
 * \brief Fonction exemple à exécuter dans le processus enfant.
 *
 * La fonction child_function() est un exemple de fonction qui peut être exécutée dans le processus enfant.
 * Elle prend un pointeur vers un entier, affiche sa valeur, simule un travail en dormant pendant 2 secondes,
 * puis affiche un message indiquant que le travail est terminé.
 *
 * \param arg Un pointeur vers un entier contenant la valeur à afficher.
 */
void child_function(void *arg) // exemple
{
    int *value = (int *)arg;
    printf("Child process: value = %d\n", *value);
    // Simuler un travail
    sleep(2);
    printf("Child process: work done\n");
}
/**
 * \brief Ouvre un répertoire.
 *
 * La fonction open_directory() ouvre un répertoire spécifié par son nom en utilisant la fonction opendir().
 * Si l'ouverture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param dirname Le nom du répertoire à ouvrir.
 * \return Un pointeur vers le répertoire ouvert (DIR*), ou NULL en cas d'échec.
 */
DIR* open_directory(const char *dirname)
{
    DIR *dir = opendir(dirname);
    if (dir == NULL)
    {
        perror("opendir");
        exit(EXIT_FAILURE);
    }
    return dir;
}
/**
 * \brief Ferme un répertoire.
 *
 * La fonction close_directory() ferme un répertoire ouvert en utilisant la fonction closedir().
 * Si la fermeture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param dir Le pointeur vers le répertoire à fermer.
 */
void close_directory(DIR *dir)
{
    if (closedir(dir) == -1)
    {
        perror("closedir");
        exit(EXIT_FAILURE);
    }
}
/**
 * \brief Lit les entrées d'un répertoire.
 *
 * La fonction read_directory() lit toutes les entrées d'un répertoire ouvert et les stocke dans un tableau de chaînes de caractères.
 * Elle utilise readdir() pour lire chaque entrée du répertoire et strdup() pour dupliquer les noms des entrées.
 * Si une allocation de mémoire échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param dir Le pointeur vers le répertoire ouvert.
 * \param count Un pointeur vers un entier où sera stocké le nombre d'entrées lues.
 * \return Un tableau de chaînes de caractères contenant les noms des entrées du répertoire, ou NULL en cas d'échec.
 */
char** read_directory(DIR *dir, int *count)
{
    struct dirent *entry;
    char **entries = NULL;
    int capacity = 10;
    int size = 0;
    entries = (char**)malloc(capacity * sizeof(char*));
    if (entries == NULL)
    {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    while ((entry = readdir(dir)) != NULL)
    {
        if (size >= capacity)
        {
            capacity *= 2;
            entries = (char**)realloc(entries, capacity * sizeof(char*));
            if (entries == NULL)
            {
                perror("realloc");
                exit(EXIT_FAILURE);
            }
        }
        entries[size] = strdup(entry->d_name);
        if (entries[size] == NULL)
        {
            perror("strdup");
            exit(EXIT_FAILURE);
        }
        size++;
    }
    *count = size;
    return entries;
}
/**
 * \brief Libère la mémoire allouée pour les entrées d'un répertoire.
 *
 * La fonction free_entries() libère la mémoire allouée pour les entrées d'un répertoire.
 * Elle parcourt le tableau d'entrées et libère chaque chaîne de caractères, puis libère le tableau lui-même.
 *
 * \param entries Le tableau de chaînes de caractères contenant les noms des entrées du répertoire.
 * \param count Le nombre d'entrées dans le tableau.
 */
void free_entries(char **entries, int count)
{
    for (int i = 0; i < count; i++)
    {
        free(entries[i]);
    }
    free(entries);
}
/**
 * \brief Crée un pipe.
 *
 * La fonction create_pipe() crée un pipe en utilisant la fonction pipe().
 * Si la création du pipe échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \return 0 si la création du pipe réussit, sinon termine le programme.
 */
int create_pipe()
{
    int pipefd[2];
    if (pipe(pipefd) == -1)
    {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    return 0;
}
/**
 * \brief Redirige l'entrée standard vers la sortie du pipe.
 *
 * La fonction redirect_stdin_to_pipeout() utilise dup2() pour rediriger l'entrée standard (STDIN_FILENO)
 * vers la sortie du pipe (pipefd). Si la redirection échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param pipefd Le descripteur de fichier du pipe.
 */
void redirect_stdin_to_pipeout(int pipefd)
{
    if (dup2(pipefd, STDIN_FILENO) == -1)
    {
        perror("dup2");
        exit(EXIT_FAILURE);
    }
    close(pipefd);
}
/**
 * \brief Redirige la sortie standard vers l'entrée du pipe.
 *
 * La fonction redirect_stdout_to_pipein() utilise dup2() pour rediriger la sortie standard (STDOUT_FILENO)
 * vers l'entrée du pipe (pipefd). Si la redirection échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param pipefd Le descripteur de fichier du pipe.
 */
void redirect_stdout_to_pipein(int pipefd)
{
    if (dup2(pipefd, STDOUT_FILENO) == -1)
    {
        perror("dup2");
        exit(EXIT_FAILURE);
    }
    close(pipefd);
}
/**
 * \brief Redirige la sortie d'erreur standard vers l'entrée du pipe.
 *
 * La fonction redirect_stderr_to_pipein() utilise dup2() pour rediriger la sortie d'erreur standard (STDERR_FILENO)
 * vers l'entrée du pipe (pipefd). Si la redirection échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param pipefd Le descripteur de fichier du pipe.
 */
void redirect_stderr_to_pipein(int pipefd)
{
    if (dup2(pipefd, STDERR_FILENO) == -1)
    {
        perror("dup2");
        exit(EXIT_FAILURE);
    }
    close(pipefd);
}
/**
 * \brief Lit des données à partir d'un pipe.
 *
 * La fonction read_from_pipe() lit des données à partir d'un pipe en utilisant la fonction read().
 * Si la lecture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param fd Le descripteur de fichier du pipe.
 * \param buf Le buffer où stocker les données lues.
 * \param count Le nombre d'octets à lire.
 * \return Le nombre d'octets lus, ou -1 en cas d'échec.
 */
ssize_t read_from_pipe(int fd, void *buf, size_t count)
{
    ssize_t n = read(fd, buf, count);
    if (n == -1)
    {
        perror("read");
        exit(EXIT_FAILURE);
    }
    return n;
}
/**
 * \brief Écrit des données dans un pipe.
 *
 * La fonction write_to_pipe() écrit des données dans un pipe en utilisant la fonction write().
 * Si l'écriture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param fd Le descripteur de fichier du pipe.
 * \param buf Le buffer contenant les données à écrire.
 * \param count Le nombre d'octets à écrire.
 * \return Le nombre d'octets écrits, ou -1 en cas d'échec.
 */
ssize_t write_to_pipe(int fd, const void *buf, size_t count)
{
    ssize_t n = write(fd, buf, count);
    if (n == -1)
    {
        perror("write");
        exit(EXIT_FAILURE);
    }
    return n;
}
/**
 * \brief Ferme un pipe.
 *
 * La fonction close_pipe() ferme les deux extrémités d'un pipe en utilisant la fonction close().
 * Si la fermeture échoue, elle affiche un message d'erreur et termine le programme.
 *
 * \param pipefd Un tableau de deux descripteurs de fichier représentant les deux extrémités du pipe.
 */
void close_pipe(int pipefd[2])
{
    if (close(pipefd[0]) == -1 || close(pipefd[1]) == -1)
    {
        perror("close");
        exit(EXIT_FAILURE);
    }
}
